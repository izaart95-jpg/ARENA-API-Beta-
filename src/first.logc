// Run this in the browser console on arena.ai

(function() {
    // Store for the token
    let capturedToken = null;
    let tokenSource = null;
    
    // Store original fetch
    const originalFetch = window.fetch;
    
    console.log('üîç Interceptor active - watching for reCAPTCHA requests...');
    
    // Override fetch
    window.fetch = function(...args) {
        const [url, options] = args;
        const urlStr = url.toString();
        
        // Check if this is a reCAPTCHA reload request
        if (urlStr.includes('recaptcha/enterprise/reload') && options?.method === 'POST') {
            console.log('üéØ Intercepted reCAPTCHA reload request');
            
            // Capture the request body
            const requestBody = options.body;
            console.log('üì¶ Reload request body captured');
            
            // Intercept the response to extract token
            return originalFetch.apply(this, args)
                .then(response => {
                    // Clone response so we can read it
                    const clonedResponse = response.clone();
                    
                    // Read the response as text
                    clonedResponse.text().then(responseText => {
                        try {
                            // The reload response appears to contain the token in a specific format
                            // It looks like ["rresp","TOKEN",...]
                            const parsed = JSON.parse(responseText);
                            if (Array.isArray(parsed) && parsed[0] === 'rresp' && parsed[1]) {
                                capturedToken = parsed[1];
                                tokenSource = 'reload';
                                console.log('‚úÖ TOKEN CAPTURED from reload response:', capturedToken);
                                console.log('üìã Token copied to clipboard? You can manually copy it now');
                                
                                // Try to copy to clipboard
                                try {
                                    const textarea = document.createElement('textarea');
                                    textarea.value = capturedToken;
                                    document.body.appendChild(textarea);
                                    textarea.select();
                                    document.execCommand('copy');
                                    document.body.removeChild(textarea);
                                    console.log('üìã Token copied to clipboard automatically!');
                                } catch (clipError) {
                                    console.log('üìã Manual copy required - select and copy the token above');
                                }
                            }
                        } catch (e) {
                            console.log('‚ö†Ô∏è Could not parse reload response', e);
                        }
                    });
                    
                    return response;
                });
        }
        
        // Check for the evaluation request that uses the token
        if (urlStr.includes('post-to-evaluation') && options?.method === 'POST') {
            console.log('üö´ Blocked evaluation request that would use the token');
            
            // Parse the request body to see the token
            try {
                const bodyData = JSON.parse(options.body);
                if (bodyData.recaptchaV3Token) {
                    console.log('üîë Token found in evaluation request:', bodyData.recaptchaV3Token);
                    
                    // If we haven't captured the token yet, capture it from here
                    if (!capturedToken) {
                        capturedToken = bodyData.recaptchaV3Token;
                        tokenSource = 'evaluation';
                        console.log('‚úÖ TOKEN CAPTURED from evaluation request:', capturedToken);
                        
                        try {
                            const textarea = document.createElement('textarea');
                            textarea.value = capturedToken;
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                            console.log('üìã Token copied to clipboard automatically!');
                        } catch (clipError) {
                            console.log('üìã Manual copy required - select and copy the token above');
                        }
                    }
                }
            } catch (e) {
                console.log('Could not parse evaluation body');
            }
            
            // BLOCK the evaluation request - return a fake successful response
            return Promise.resolve(new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
            }));
        }
        
        // Check for reCAPTCHA clr request (clear)
        if (urlStr.includes('recaptcha/enterprise/clr')) {
            console.log('üõë Blocked reCAPTCHA clr request');
            // Block the clr request to prevent cleanup
            return Promise.resolve(new Response(null, { status: 200 }));
        }
        
        // Pass through all other requests
        return originalFetch.apply(this, args);
    };
    
    // Also monitor XHR requests as backup
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function(...args) {
        this._interceptedUrl = args[1];
        return originalXHROpen.apply(this, args);
    };
    
    XMLHttpRequest.prototype.send = function(...args) {
        const url = this._interceptedUrl || '';
        
        // Check for evaluation XHR
        if (url.includes('post-to-evaluation')) {
            console.log('üö´ Blocked evaluation XHR');
            // Override onreadystatechange to prevent actual request
            this.onreadystatechange = null;
            // Return fake success
            setTimeout(() => {
                if (this.onreadystatechange) {
                    // Fake readyState 4 (done) with status 200
                    Object.defineProperty(this, 'readyState', { value: 4 });
                    Object.defineProperty(this, 'status', { value: 200 });
                    Object.defineProperty(this, 'responseText', { 
                        value: JSON.stringify({ success: true }) 
                    });
                    this.onreadystatechange();
                }
                if (this.onload) this.onload();
            }, 100);
            return;
        }
        
        return originalXHRSend.apply(this, args);
    };
    
    console.log('‚úÖ Interceptor installed!');
    console.log('‚ÑπÔ∏è Waiting for reCAPTCHA reload request...');
    console.log('‚ÑπÔ∏è The evaluation request will be blocked and token will be logged');
    
    // Helper function to manually extract token from any stored location
    window.getCapturedToken = function() {
        if (capturedToken) {
            console.log('üìã Captured token:', capturedToken);
            return capturedToken;
        } else {
            console.log('‚ùå No token captured yet');
            return null;
        }
    };
    
    console.log('üí° You can use window.getCapturedToken() to retrieve the token at any time');
})();
